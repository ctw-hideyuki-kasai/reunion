<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>PROMISE 2031 - 再会の約束</title>
    <!-- Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- Google Fonts -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700&family=Zen+Kaku+Gothic+New:wght@300;500&display=swap" rel="stylesheet">
    <style>
        body { margin: 0; overflow: hidden; background-color: #000; color: white; font-family: 'Zen Kaku Gothic New', sans-serif; }
        #canvas-container { position: absolute; top: 0; left: 0; width: 100%; height: 100%; z-index: 1; }
        #ui-layer { position: absolute; top: 0; left: 0; width: 100%; height: 100%; z-index: 10; pointer-events: none; }
        .pointer-events-auto { pointer-events: auto; }
        .glass-panel {
            background: rgba(16, 20, 30, 0.4);
            backdrop-filter: blur(8px);
            border: 1px solid rgba(255, 255, 255, 0.1);
            box-shadow: 0 4px 30px rgba(0, 0, 0, 0.5);
        }
        .orbitron { font-family: 'Orbitron', sans-serif; }
        
        /* Loading Animation */
        #loader {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background: #000; z-index: 50; display: flex; justify-content: center; align-items: center;
            transition: opacity 1s ease-out;
        }
        .loader-text {
            animation: pulse 2s infinite;
        }
        @keyframes pulse {
            0% { opacity: 0.5; }
            50% { opacity: 1; }
            100% { opacity: 0.5; }
        }

        /* Clickable objects cursor */
        canvas { cursor: grab; }
        canvas:active { cursor: grabbing; }
    </style>
</head>
<body>

    <!-- Loading Screen -->
    <div id="loader">
        <div class="text-center">
            <h1 class="text-2xl orbitron tracking-widest text-blue-400 loader-text">INITIALIZING ORBIT...</h1>
            <p class="text-xs text-gray-500 mt-2">Target Date: April 2031</p>
        </div>
    </div>

    <!-- 3D Background -->
    <div id="canvas-container"></div>

    <!-- UI Overlay -->
    <div id="ui-layer" class="flex flex-col justify-between p-6 md:p-12">
        
        <!-- Header -->
        <header class="flex justify-between items-start animate-fade-in-down pointer-events-auto">
            <div>
                <h1 class="text-3xl md:text-5xl font-bold orbitron tracking-widest text-transparent bg-clip-text bg-gradient-to-r from-blue-300 to-purple-400">
                    PROMISE
                </h1>
                <p class="text-sm md:text-base text-gray-400 mt-1 tracking-widest">PROJECT YODO 2031</p>
            </div>
            <button onclick="toggleMusic()" class="glass-panel p-3 rounded-full hover:bg-white/10 transition group hidden">
                <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5 text-gray-300 group-hover:text-white" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M15.536 8.464a5 5 0 010 7.072m2.828-9.9a9 9 0 010 12.728M5.586 15H4a1 1 0 01-1-1v-4a1 1 0 011-1h1.586l4.707-4.707C10.923 3.663 12 4.109 12 5v14c0 .891-1.077 1.337-1.707.707L5.586 15z" />
                </svg>
            </button>
        </header>

        <!-- Center Message (Initially Hidden, shows on click) -->
        <div id="message-modal" class="absolute top-1/2 left-1/2 transform -translate-x-1/2 -translate-y-1/2 pointer-events-auto opacity-0 pointer-events-none transition-all duration-500 z-40 w-full max-w-lg px-4">
            <div class="glass-panel p-8 rounded-xl text-center relative overflow-hidden">
                <div class="absolute top-0 left-0 w-full h-1 bg-gradient-to-r from-blue-500 via-purple-500 to-pink-500"></div>
                <h2 id="modal-title" class="text-xl md:text-2xl font-bold mb-4 orbitron text-blue-200"></h2>
                <p id="modal-text" class="text-gray-300 leading-relaxed text-sm md:text-base"></p>
                <button onclick="closeModal()" class="mt-6 px-6 py-2 border border-white/20 rounded hover:bg-white/10 transition text-sm tracking-widest">CLOSE</button>
            </div>
        </div>

        <!-- Footer / Countdown -->
        <footer class="glass-panel p-6 rounded-xl md:rounded-2xl max-w-4xl mx-auto w-full mb-4 pointer-events-auto transform hover:scale-[1.01] transition duration-500">
            <div class="flex flex-col md:flex-row justify-between items-center gap-6">
                <div class="text-center md:text-left">
                    <p class="text-xs text-gray-400 uppercase tracking-widest mb-1">Mission Objective</p>
                    <p class="text-lg font-medium">5年後の再会</p>
                    <p class="text-xs text-gray-500 mt-1">Destination: Tokyo / April 1st, 2031</p>
                </div>
                
                <div class="flex flex-col items-center md:items-end">
                    <p class="text-xs text-blue-300 uppercase tracking-widest mb-1 animate-pulse">Time Remaining</p>
                    <div class="flex gap-4 font-mono orbitron text-2xl md:text-4xl">
                        <div class="text-center">
                            <span id="days">0000</span>
                            <span class="block text-[10px] text-gray-500 font-sans">DAYS</span>
                        </div>
                        <div class="text-gray-600">:</div>
                        <div class="text-center">
                            <span id="hours">00</span>
                            <span class="block text-[10px] text-gray-500 font-sans">HRS</span>
                        </div>
                        <div class="text-gray-600">:</div>
                        <div class="text-center">
                            <span id="minutes">00</span>
                            <span class="block text-[10px] text-gray-500 font-sans">MIN</span>
                        </div>
                        <div class="text-gray-600">:</div>
                        <div class="text-center">
                            <span id="seconds">00</span>
                            <span class="block text-[10px] text-gray-500 font-sans">SEC</span>
                        </div>
                    </div>
                </div>
            </div>
        </footer>
    </div>

    <!-- Three.js Library -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <!-- OrbitControls Plugin -->
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
    
    <script>
        // --- Configuration ---
        const TARGET_DATE = new Date('2031-04-01T12:00:00'); // 2031年4月1日
        
        // 太陽をクリックした時の遷移先URL
        const SUN_LINK_URL = "https://claytechworks.co.jp"; 

        // Messages for planets
        const PLANET_DATA = [
            {
                name: "THE DEPARTURE",
                desc: "旅立つ君へ。この5年間は長いようで一瞬かもしれない。新しい環境での挑戦、心から応援している。どんなに遠くにいても、この軌道のように僕らは繋がっている。",
                color: 0x4aa8ff, // Blue
                size: 1.2,
                orbitRadius: 18,
                speed: 0.005
            },
            {
                name: "THE CHALLENGE",
                desc: "未知の世界は時に厳しいけれど、それは君を強くする糧になる。壁にぶつかった時は、ここでの日々を思い出して。君なら必ず乗り越えられる。",
                color: 0x20b2aa, // LightSeaGreen
                size: 1.0,
                orbitRadius: 24,
                speed: 0.004
            },
            {
                name: "THE RETURN",
                desc: "5年後の自分たちへ。今の情熱と約束を忘れないでほしい。大きくなって、胸を張って再会しよう。2031年の春、最高の笑顔で。",
                color: 0xff4a6e, // Pink/Red
                size: 0.9,
                orbitRadius: 30,
                speed: 0.003
            },
            {
                name: "THE BOND",
                desc: "物理的な距離は、心の距離を測るものじゃない。空を見上げれば同じ星が輝いているように、僕たちの絆は決して消えない。いつでも味方でいるよ。",
                color: 0xffd700, // Gold
                size: 1.1,
                orbitRadius: 38,
                speed: 0.002
            }
        ];

        // --- Three.js Setup ---
        const container = document.getElementById('canvas-container');
        const scene = new THREE.Scene();
        scene.fog = new THREE.FogExp2(0x050505, 0.015); // Fog color slightly adjusted

        const camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
        // 初期位置を遠くに設定（ズームアニメーション用）
        const INITIAL_CAMERA_Z = 800;
        const TARGET_CAMERA_Z = 40;
        camera.position.z = INITIAL_CAMERA_Z;
        camera.position.y = 100; // Yも少し高くして俯瞰から入る
        camera.lookAt(0,0,0);

        const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(window.devicePixelRatio);
        renderer.outputEncoding = THREE.sRGBEncoding;
        renderer.toneMapping = THREE.ACESFilmicToneMapping;
        container.appendChild(renderer.domElement);

        // --- OrbitControls Setup ---
        const controls = new THREE.OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;
        controls.dampingFactor = 0.05;
        controls.enablePan = false;
        controls.minDistance = 10;
        controls.maxDistance = 90;
        controls.autoRotate = true;
        controls.autoRotateSpeed = 0.5;
        // アニメーション中は操作を無効化
        controls.enabled = false;

        // --- Lights ---
        const ambientLight = new THREE.AmbientLight(0x333333);
        scene.add(ambientLight);

        // Main Sun Light
        const sunLight = new THREE.PointLight(0xffaa00, 1.5, 100);
        sunLight.position.set(0, 0, 0);
        scene.add(sunLight);

        // --- Helper Function: Create Glow Texture ---
        function createGlowTexture() {
            const canvas = document.createElement('canvas');
            canvas.width = 128;
            canvas.height = 128;
            const context = canvas.getContext('2d');
            // Gradient from white/yellow to transparent
            const gradient = context.createRadialGradient(64, 64, 0, 64, 64, 64);
            gradient.addColorStop(0, 'rgba(255, 255, 255, 1)');
            gradient.addColorStop(0.2, 'rgba(255, 240, 150, 0.6)');
            gradient.addColorStop(0.4, 'rgba(255, 100, 0, 0.2)');
            gradient.addColorStop(1, 'rgba(0, 0, 0, 0)');
            
            context.fillStyle = gradient;
            context.fillRect(0, 0, 128, 128);
            
            const texture = new THREE.CanvasTexture(canvas);
            return texture;
        }

        // --- Objects ---

        // 1. The Sun
        const sunGroup = new THREE.Group();
        scene.add(sunGroup);

        const sunGeometry = new THREE.SphereGeometry(2, 32, 32);
        const sunMaterial = new THREE.MeshBasicMaterial({ color: 0xffffff });
        const sun = new THREE.Mesh(sunGeometry, sunMaterial);
        
        // 太陽にクリック判定用のデータを追加
        sun.userData = { isSun: true };
        
        sunGroup.add(sun);
        
        const spriteMaterial = new THREE.SpriteMaterial({ 
            map: createGlowTexture(), 
            color: 0xffddaa, 
            transparent: true, 
            blending: THREE.AdditiveBlending 
        });
        const sunSprite = new THREE.Sprite(spriteMaterial);
        sunSprite.scale.set(15, 15, 1); 
        sunGroup.add(sunSprite);

        const sunHaloGeo = new THREE.SphereGeometry(2.2, 32, 32);
        const sunHaloMat = new THREE.MeshBasicMaterial({
            color: 0xffaa00,
            transparent: true,
            opacity: 0.4,
            side: THREE.BackSide
        });
        const sunHalo = new THREE.Mesh(sunHaloGeo, sunHaloMat);
        sunGroup.add(sunHalo);

        // 2. Planets
        const planets = [];
        const orbitRings = [];

        PLANET_DATA.forEach(data => {
            const ringGeo = new THREE.RingGeometry(data.orbitRadius - 0.05, data.orbitRadius + 0.05, 128);
            const ringMat = new THREE.MeshBasicMaterial({ 
                color: 0xffffff, 
                side: THREE.DoubleSide, 
                transparent: true, 
                opacity: 0.15,
                blending: THREE.AdditiveBlending
            });
            const ring = new THREE.Mesh(ringGeo, ringMat);
            ring.rotation.x = Math.PI / 2;
            scene.add(ring);
            orbitRings.push(ring);

            const pivot = new THREE.Object3D();
            pivot.rotation.y = Math.random() * Math.PI * 2; 
            scene.add(pivot);

            const geometry = new THREE.SphereGeometry(data.size, 32, 32);
            const material = new THREE.MeshStandardMaterial({ 
                color: data.color,
                roughness: 0.4,
                metalness: 0.3,
                emissive: data.color,
                emissiveIntensity: 0.4
            });
            const planet = new THREE.Mesh(geometry, material);
            planet.position.x = data.orbitRadius;
            
            planet.userData = { 
                name: data.name, 
                desc: data.desc,
                isInteractive: true 
            };

            const planetGlowMat = new THREE.SpriteMaterial({
                map: createGlowTexture(),
                color: data.color,
                transparent: true,
                opacity: 0.5,
                blending: THREE.AdditiveBlending
            });
            const planetGlow = new THREE.Sprite(planetGlowMat);
            planetGlow.scale.set(data.size * 5, data.size * 5, 1);
            planet.add(planetGlow);

            pivot.add(planet);
            planets.push({ mesh: planet, pivot: pivot, speed: data.speed });
        });

        // 3. Stars
        const starsGeometry = new THREE.BufferGeometry();
        const starsCount = 3000;
        const posArray = new Float32Array(starsCount * 3);

        for(let i = 0; i < starsCount * 3; i++) {
            posArray[i] = (Math.random() - 0.5) * 200; 
        }

        starsGeometry.setAttribute('position', new THREE.BufferAttribute(posArray, 3));
        const starsMaterial = new THREE.PointsMaterial({
            size: 0.2,
            color: 0xaaddff,
            transparent: true,
            opacity: 0.8,
            blending: THREE.AdditiveBlending
        });
        const starField = new THREE.Points(starsGeometry, starsMaterial);
        scene.add(starField);

        // --- Interaction Logic ---
        const raycaster = new THREE.Raycaster();
        const mouse = new THREE.Vector2();
        
        let isDragging = false;
        let mouseDownPos = { x: 0, y: 0 };

        function onMouseDown(event) {
            isDragging = false;
            mouseDownPos = { x: event.clientX, y: event.clientY };
        }

        function onMouseMove(event) {
            mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
        }
        
        function onMouseUp(event) {
            const moveX = Math.abs(event.clientX - mouseDownPos.x);
            const moveY = Math.abs(event.clientY - mouseDownPos.y);
            if (moveX > 5 || moveY > 5) {
                isDragging = true;
            }
        }

        function onClick(event) {
            if (isDragging) return;

            raycaster.setFromCamera(mouse, camera);
            
            const targets = [...planets.map(p => p.mesh), sun];
            const intersects = raycaster.intersectObjects(targets);

            if (intersects.length > 0) {
                const object = intersects[0].object;
                
                if (object.userData.isSun) {
                    window.location.href = SUN_LINK_URL;
                    return;
                }

                if (object.userData.isInteractive) {
                    showModal(object.userData.name, object.userData.desc);
                    controls.autoRotate = false;
                }
            } else {
                closeModal();
            }
        }
        
        function onTouchEnd(event) {
             mouse.x = (event.changedTouches[0].clientX / window.innerWidth) * 2 - 1;
             mouse.y = -(event.changedTouches[0].clientY / window.innerHeight) * 2 + 1;
        }

        window.addEventListener('mousedown', onMouseDown);
        window.addEventListener('mousemove', onMouseMove);
        window.addEventListener('mouseup', onMouseUp);
        window.addEventListener('click', onClick);
        
        // モーダル
        const modal = document.getElementById('message-modal');
        const modalTitle = document.getElementById('modal-title');
        const modalText = document.getElementById('modal-text');

        function showModal(title, text) {
            modalTitle.innerText = title;
            modalText.innerText = text;
            modal.classList.remove('opacity-0', 'pointer-events-none');
            modal.classList.add('opacity-100', 'pointer-events-auto');
        }

        function closeModal() {
            modal.classList.remove('opacity-100', 'pointer-events-auto');
            modal.classList.add('opacity-0', 'pointer-events-none');
            controls.autoRotate = true;
        }

        // --- Intro Zoom Animation ---
        function playIntroZoom() {
            const startZ = INITIAL_CAMERA_Z;
            const startY = 100;
            const endZ = TARGET_CAMERA_Z;
            const endY = 10;
            const duration = 1500; // 1.5 seconds
            const startTime = Date.now();

            function loop() {
                const now = Date.now();
                const progress = Math.min((now - startTime) / duration, 1);
                
                // Ease out cubic
                const ease = 1 - Math.pow(1 - progress, 3);
                
                camera.position.z = startZ + (endZ - startZ) * ease;
                camera.position.y = startY + (endY - startY) * ease;
                camera.lookAt(0,0,0);
                
                if (progress < 1) {
                    requestAnimationFrame(loop);
                } else {
                    // Animation Complete
                    controls.enabled = true; // Enable User Control
                }
            }
            loop();
        }

        // --- Animation Loop ---
        function animate() {
            requestAnimationFrame(animate);

            // Controls update
            if (controls.enabled) {
                controls.update();
            }

            // Rotate planets
            planets.forEach(p => {
                p.pivot.rotation.y += p.speed;
                p.mesh.rotation.y += 0.01; 
            });

            // Rotate starfield slowly
            starField.rotation.y -= 0.0002;

            // Pulse Sun Glow
            const time = Date.now() * 0.001;
            sunSprite.scale.setScalar(14 + Math.sin(time * 2) * 1.5);

            renderer.render(scene, camera);
        }

        animate();

        // --- Window Resize ---
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

        // --- Countdown Logic ---
        function updateCountdown() {
            const now = new Date();
            const diff = TARGET_DATE - now;

            if (diff <= 0) {
                document.getElementById('days').innerText = "0000";
                document.getElementById('hours').innerText = "00";
                document.getElementById('minutes').innerText = "00";
                document.getElementById('seconds').innerText = "00";
                return;
            }

            const days = Math.floor(diff / (1000 * 60 * 60 * 24));
            const hours = Math.floor((diff % (1000 * 60 * 60 * 24)) / (1000 * 60 * 60));
            const minutes = Math.floor((diff % (1000 * 60 * 60)) / (1000 * 60));
            const seconds = Math.floor((diff % (1000 * 60)) / 1000);

            document.getElementById('days').innerText = days.toString().padStart(4, '0');
            document.getElementById('hours').innerText = hours.toString().padStart(2, '0');
            document.getElementById('minutes').innerText = minutes.toString().padStart(2, '0');
            document.getElementById('seconds').innerText = seconds.toString().padStart(2, '0');
        }

        setInterval(updateCountdown, 1000);
        updateCountdown();

        // --- Init ---
        window.onload = () => {
            setTimeout(() => {
                document.getElementById('loader').style.opacity = '0';
                
                // Start Zoom-in Animation
                playIntroZoom();

                setTimeout(() => {
                    document.getElementById('loader').style.display = 'none';
                }, 1000);
            }, 1500);
        };

    </script>
</body>
</html>